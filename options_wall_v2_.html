
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <title>Options Wall V2 - 2025-12-24</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", sans-serif;
      margin: 16px;
      background-color: #0f172a;
      color: #e5e7eb;
    }
    h1 {
      font-size: 20px;
      margin: 0 0 4px 0;
    }
    .meta {
      font-size: 12px;
      color: #9ca3af;
      margin-bottom: 8px;
    }
    a {
      color: #60a5fa;
      text-decoration: none;
      font-size: 14px;
    }
    a:hover {
      text-decoration: underline;
    }
    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      margin-bottom: 12px;
    }
    .toolbar label, .toolbar span {
      font-size: 12px;
      color: #9ca3af;
      margin-right: 4px;
    }
    select, button.dte-tab, button.side-tab {
      font-size: 12px;
      padding: 3px 8px;
      border-radius: 6px;
      border: 1px solid #4b5563;
      background-color: #020617;
      color: #e5e7eb;
    }
    button.dte-tab, button.side-tab {
      cursor: pointer;
      border: 1px solid #374151;
      background-color: #020617;
      transition: background-color 0.15s, border-color 0.15s;
    }
    button.dte-tab.active, button.side-tab.active {
      background-color: #1d4ed8;
      border-color: #60a5fa;
      color: #f9fafb;
    }
    .panel-title {
      font-size: 14px;
      margin: 12px 0 4px 0;
      color: #e5e7eb;
      display: flex;
      justify-content: space-between;
      align-items: baseline;
    }
    .panel-subtitle {
      font-size: 11px;
      color: #9ca3af;
    }
    .chart {
      width: 100%;
      height: 320px;
      border-radius: 8px;
      border: 1px solid #1f2937;
      margin-bottom: 4px;
      background-color: #020617;
    }
    .interpret {
      font-size: 11px;
      color: #9ca3af;
      margin-bottom: 10px;
    }
    .disclaimer-block {
      margin-top: 18px;
      padding: 10px 12px;
      border-radius: 10px;
      background-color: #020617;
      border: 1px solid #1f2937;
    }
    .disclaimer-title {
      font-size: 15px;
      margin: 0 0 6px 0;
      font-weight: 600;
    }
    .disclaimer-text {
      font-size: 22px;  /* å¤§ä¸€å€ */
      color: #9ca3af;
      line-height: 1.7;
      margin: 0;
    }

  </style>
</head>
<body>
  <h1>Options Wall V2</h1>
  <div style="margin-bottom: 4px;">
    <a href="index.html">&larr; è¿”å›é¦–é¡µ</a>
  </div>
  <div class="meta">
    äº¤æ˜“æ—¥ï¼š2025-12-24 Â· Î”åä¹‰ = |Î”| Ã— OI Ã— ä¹˜æ•° Ã— æ ‡çš„ä»· Â· å†å²çª—å£ï¼šæœ€è¿‘ 60 å¤©
  </div>

  <!-- é¡¶éƒ¨ï¼šæ ‡çš„ + DTE æ¡¶ -->
  <div class="toolbar">
    <div>
      <label for="symbol-select">æ ‡çš„ï¼š</label>
      <select id="symbol-select"></select>
    </div>
    <div id="dte-tabs"></div>
  </div>

  <!-- ç¬¬ä¸€å±‚ï¼šDTE æ¨ªæˆªé¢ï¼ˆåªç”¨æ¥é€‰ä»·ä½ï¼‰ -->
  <div class="panel-title">
    <div>â‘  DTE æ¨ªæˆªé¢å¢™ï¼ˆè¿‡æ»¤åçš„ Top10 è¡Œæƒä»·ï¼‰</div>
    <div class="panel-subtitle" id="main-subtitle"></div>
  </div>
  <div id="main-chart" class="chart"></div>
  <div id="main-interpret" class="interpret"></div>

  <!-- ç¬¬äºŒå±‚ï¼šCall / Put åˆ‡æ¢ï¼ˆæ˜ç¡®ä¸¤ä¸ªæŒ‰é’®ï¼‰ -->
  <div class="toolbar" style="margin-top:4px;margin-bottom:4px;">
    <div id="side-tabs" style="display:flex;align-items:center;gap:6px;">
      <span>ç¬¬äºŒå±‚ä¾§åˆ«ï¼ˆç‚¹å‡»åˆ‡æ¢ï¼‰ï¼š</span>
      <button id="side-call-btn" type="button" class="side-tab active" data-side="C">Call</button>
      <button id="side-put-btn" type="button" class="side-tab" data-side="P">Put</button>
    </div>
  </div>

  <!-- ç¬¬äºŒå±‚ï¼šåˆ°æœŸæ—¥åˆ†å¸ƒ -->
  <div class="panel-title">
    <div>â‘¡ åˆ°æœŸæ—¥åˆ†å¸ƒï¼ˆå…ˆé€‰ä»·ä½ï¼Œå†é€‰ Call / Putï¼‰</div>
    <div class="panel-subtitle" id="expiry-subtitle"></div>
  </div>
  <div id="expiry-chart" class="chart"></div>
  <div id="expiry-interpret" class="interpret"></div>

  <!-- ç¬¬ä¸‰å±‚ï¼šå†å² OI / Volume -->
  <div class="panel-title">
    <div>â‘¢ å¢™çš„å†å² OI / æˆäº¤é‡è½¨è¿¹ï¼ˆå†ç‚¹æŸä¸ªåˆ°æœŸæ—¥æŸ±å­ï¼‰</div>
    <div class="panel-subtitle" id="history-subtitle"></div>
  </div>
  <div id="history-chart" class="chart"></div>
  <div id="history-interpret" class="interpret"></div>

    <div class="disclaimer-block">
    <div class="disclaimer-title">å…è´£å£°æ˜</div>
    <p class="disclaimer-text">
      æœ¬ææ–™ç”±ä¸ªäººç ”ç©¶å·¥å…·è‡ªåŠ¨ç”Ÿæˆï¼Œæ‰€è½½å†…å®¹ä»…ä¸ºå¯¹å…¬å¼€å¸‚åœºæ•°æ®çš„å®¢è§‚æ•´ç†ä¸é‡åŒ–ç»“æœå±•ç¤ºï¼Œ
      ä¸æ„æˆã€äº¦ä¸åº”è¢«è§†ä¸ºä»»ä½•å½¢å¼çš„è¯åˆ¸æˆ–æœŸè´§æŠ•èµ„å»ºè®®ã€ä¹°å–è¦çº¦æˆ–æŠ•èµ„æ‰¿è¯ºã€‚æœ¬ææ–™æœªè€ƒè™‘ä»»ä½•æŠ•èµ„è€…çš„å…·ä½“æŠ•èµ„ç›®æ ‡ã€
      è´¢åŠ¡çŠ¶å†µåŠé£é™©æ‰¿å—èƒ½åŠ›ï¼Œç›¸å…³è§‚ç‚¹å’Œç»“è®ºäº¦å¯èƒ½éšå¸‚åœºç¯å¢ƒå˜åŒ–è€Œä¸å†é€‚ç”¨ã€‚æœŸæƒåŠå…¶ä»–è¡ç”Ÿå“äº¤æ˜“å…·æœ‰é«˜åº¦é£é™©ï¼Œ
      å¯èƒ½å¯¼è‡´è¿œè¶…åˆå§‹æŠ•å…¥çš„æŸå¤±ã€‚è¯·åœ¨ç‹¬ç«‹åˆ¤æ–­çš„åŸºç¡€ä¸Šè‡ªè¡Œä½œå‡ºæŠ•èµ„å†³ç­–ï¼Œå¹¶åœ¨å¿…è¦æ—¶å’¨è¯¢å…·å¤‡ç›¸åº”èµ„è´¨çš„ä¸“ä¸šæœºæ„ï¼›
      ä½¿ç”¨æœ¬ææ–™è¿›è¡Œçš„ä»»ä½•æŠ•èµ„è¡Œä¸ºåŠå…¶åæœç”±æŠ•èµ„è€…è‡ªè¡Œæ‰¿æ‹…ã€‚
    </p>
  </div>

    <script>
    (function () {
      async function initAll() {
        try {
          // 1ï¼‰ä»åŒç›®å½•åŠ è½½ JSON æ•°æ®
          const [snapshotResp, historyResp] = await Promise.all([
            fetch("options_wall_v2_data.json"),
            fetch("options_wall_v2_history.json"),
          ]);

          if (!snapshotResp.ok) {
            throw new Error("åŠ è½½ options_wall_v2_data.json å¤±è´¥ï¼š" + snapshotResp.status);
          }
          if (!historyResp.ok) {
            throw new Error("åŠ è½½ options_wall_v2_history.json å¤±è´¥ï¼š" + historyResp.status);
          }

          const data = await snapshotResp.json();
          const hist = await historyResp.json();

          // è°ƒè¯•ç”¨ï¼šåœ¨æ§åˆ¶å°å¯ä»¥çœ‹åˆ°è¿™ä¸¤ä¸ªå¯¹è±¡
          window.WALL_V2_DATA = data;
          window.WALL_V2_HISTORY = hist;

          let dteBuckets = data.dte_buckets || {};
          const symbols = data.symbols || {};

          const COLORS = {
            call: "#22c55e",
            callLight: "#bbf7d0",
            put: "#ef4444",
            putLight: "#fecaca",
          };

          const symbolKeys = Object.keys(symbols);

          // ğŸ”„ å½“åç«¯æ²¡æœ‰æä¾›ä»»ä½• dte_buckets æ—¶ï¼Œè‡ªåŠ¨æ ¹æ®æœ‰æ•°æ®çš„ç¬¬ä¸€ä¸ªæ ‡çš„é€ ä¸€ä¸ªã€Œå…¨ DTEã€æ¡¶
          if (!Object.keys(dteBuckets).length && symbolKeys.length) {
            let recs = [];
            // æ‰¾åˆ°ç¬¬ä¸€ä¸ªæœ‰ records çš„æ ‡çš„
            for (const key of symbolKeys) {
              const sym = symbols[key] || {};
              if (sym.records && sym.records.length) {
                recs = sym.records;
                break;
              }
            }
            const dtes = recs
              .map(r => Number(r.dte))
              .filter(v => Number.isFinite(v));

            if (dtes.length) {
              const minDte = Math.min(...dtes);
              const maxDte = Math.max(...dtes);
              dteBuckets = {
                all: {
                  min: minDte,
                  max: maxDte,
                  label: `${minDte}-${maxDte}å¤©`,
                },
              };
            }
          }

          let currentSymbol = symbolKeys.includes("SPX")
            ? "SPX"
            : (symbolKeys.includes("SPY") ? "SPY" : (symbolKeys[0] || null));
          let currentBucketKey = Object.keys(dteBuckets)[0] || null;
          let currentStrike = null;
          let currentExpiration = null;
          let currentSideForHistory = "C";  // é»˜è®¤çœ‹ Call

          let lastMainStats = null;  // ç”¨äºä¸»å›¾è§£è¯»

          const symbolSelect = document.getElementById("symbol-select");
          const dteTabsContainer = document.getElementById("dte-tabs");
          const sideTabsContainer = document.getElementById("side-tabs");
          const mainSubtitle = document.getElementById("main-subtitle");
          const expirySubtitle = document.getElementById("expiry-subtitle");
          const historySubtitle = document.getElementById("history-subtitle");
          const mainInterpret = document.getElementById("main-interpret");
          const expiryInterpret = document.getElementById("expiry-interpret");
          const historyInterpret = document.getElementById("history-interpret");

          function normSide(val) {
            const s = (val == null ? "" : String(val)).trim().toUpperCase();
            if (s.startsWith("P")) return "P";
            return "C";
          }

          // æ‹¿å½“å‰æ ‡çš„ + DTE æ¡¶å†…æ‰€æœ‰è®°å½•
          function getRecordsForBucket(symbolKey, bucketKey) {
            const sym = symbols[symbolKey];
            if (!sym || !sym.records) return [];
            const bucket = dteBuckets[bucketKey];

            // âœ é»˜è®¤è§†ä¸ºã€Œå…¨ DTEã€
            let minDte = -Infinity;
            let maxDte = Infinity;

            // åªæœ‰å½“ bucket é‡Œé¢ç¡®å®æœ‰ min / max æ—¶æ‰æŒ‰æ¡¶è¿‡æ»¤
            if (bucket && typeof bucket.min === "number" && typeof bucket.max === "number") {
              minDte = bucket.min;
              maxDte = bucket.max;
            }

            return sym.records.filter(r => {
              const d = Number(r.dte);
              if (!Number.isFinite(d)) return false;
              return d >= minDte && d <= maxDte;
            });
          }

          // è¡Œæƒä»·èšåˆ + è¿‡æ»¤ + Top10
          function buildStrikeStats(records, underlying, bucket) {
            const map = {};
            records.forEach(r => {
              const k = String(r.strike);
              if (!map[k]) {
                map[k] = {
                  strike: r.strike,
                  callDelta: 0,
                  putDelta: 0,
                  callGamma: 0,
                  putGamma: 0
                };
              }
              const side = normSide(r.side);
              const dn = Number(r.delta_notional) || 0;
              const gn = Number(r.gamma_notional) || 0;
              if (side === "C") {
                map[k].callDelta += dn;
                map[k].callGamma += gn;
              } else {
                map[k].putDelta += dn;
                map[k].putGamma += gn;
              }
            });

            let arr = Object.values(map);
            if (!arr.length) return [];

            let maxGamma = 0;
            arr.forEach(o => {
              o.totalGamma = (o.callGamma || 0) + (o.putGamma || 0);
              if (o.totalGamma > maxGamma) maxGamma = o.totalGamma;
            });

            let applyFilter = false;
            if (bucket && typeof bucket.max === "number") {
              applyFilter = bucket.max <= 45;
            }

            if (applyFilter && underlying && underlying > 0) {
              const nearLow = 0.93;
              const nearHigh = 1.07;
              const gammaFrac = 0.25;
              arr = arr.filter(o => {
                const m = o.strike / underlying;
                const inCore = (m >= nearLow && m <= nearHigh);
                if (inCore) return true;
                if (maxGamma <= 0) return false;
                return o.totalGamma >= gammaFrac * maxGamma;
              });
            }

            if (!arr.length) return [];

            arr.forEach(o => {
              o.totalDelta = (o.callDelta || 0) + (o.putDelta || 0);
            });

            // Top10
            arr.sort((a, b) => b.totalDelta - a.totalDelta);
            arr = arr.slice(0, 10);
            arr.sort((a, b) => a.strike - b.strike);
            return arr;
          }

          // ç¬¬äºŒå±‚ï¼šå›ºå®š strike + ä¾§åˆ«ï¼ŒæŒ‰åˆ°æœŸæ—¥èšåˆ Î”
          function aggregateByExpiration(records, strike, sideFilter) {
            const tol = 1e-6;
            const sideKey = normSide(sideFilter);
            const filtered = records.filter(r => {
              if (Math.abs(Number(r.strike) - Number(strike)) > tol) return false;
              const s = normSide(r.side);
              return s === sideKey;
            });
            const map = {};
            filtered.forEach(r => {
              const exp = r.expiration;
              if (!map[exp]) {
                map[exp] = { expiration: exp, delta: 0 };
              }
              map[exp].delta += Number(r.delta_notional) || 0;
            });
            return Object.values(map);
          }

          // ç¬¬ä¸‰å±‚ï¼šå†å² OI / Volumeï¼ˆå›ºå®š symbol + strike + side + expirationï¼‰
          function getHistorySeries(symbolKey, strike, expiration, sideFilter) {
            if (!sideFilter) return [];
            const eps = 1e-6;
            const sideKey = normSide(sideFilter);

            let rows = hist.filter(r => {
              if (r.symbol !== symbolKey) return false;
              if (Math.abs(Number(r.strike) - Number(strike)) > eps) return false;
              if (r.expiration !== expiration) return false;
              const s = normSide(r.side);
              return s === sideKey;
            });

            if (!rows.length) return [];

            const byDate = {};
            rows.forEach(r => {
              const d = r.trade_date;
              if (!byDate[d]) {
                byDate[d] = {
                  trade_date: d,
                  oi: 0,
                  volume: 0,
                  delta_notional: 0,
                  gamma_notional: 0
                };
              }
              byDate[d].oi += Number(r.oi || 0);
              byDate[d].volume += Number(r.volume || 0);
              byDate[d].delta_notional += Number(r.delta_notional || 0);
              byDate[d].gamma_notional += Number(r.gamma_notional || 0);
            });

            const arr = Object.values(byDate);
            arr.sort((a, b) => (a.trade_date < b.trade_date ? -1 : (a.trade_date > b.trade_date ? 1 : 0)));
            return arr;
          }

          function makeMainInterpret(strike, stat, underlying, bucket) {
            if (!underlying || !bucket) {
              return "é€‰ä¸­è¡Œæƒä»· " + strike + "ï¼Œæ˜¾ç¤ºå½“å‰ DTE æ¡¶å†…è¯¥ä»·ä½çš„ Call / Put Î” åä¹‰ã€‚";
            }
            const dteMax = bucket.max;
            const isShort = dteMax <= 45;
            const m = strike / underlying;
            const d = (strike - underlying) / underlying * 100;
            const callDelta = stat.callDelta || 0;
            const putDelta = stat.putDelta || 0;
            let sideHint = "Call ä¸ Put æŒä»“ç›¸å¯¹å‡è¡¡";
            if (callDelta > 1.3 * putDelta) sideHint = "ä¸Šæ–¹ Call æŒä»“ç›¸å¯¹æ›´é›†ä¸­";
            else if (putDelta > 1.3 * callDelta) sideHint = "ä¸‹æ–¹ Put æŒä»“ç›¸å¯¹æ›´é›†ä¸­";

            const distText = "è¡Œæƒä»·çº¦ä¸ºæ ‡çš„ä»·çš„ " + m.toFixed(2) + " å€ï¼ˆåç¦» " + d.toFixed(1) + "%ï¼‰";

            if (isShort && Math.abs(d) <= 3) {
              return "è¿™æ˜¯ä¸€å µè¿‘æœˆã€æ¥è¿‘æ ‡çš„ä»·çš„å¢™ï¼Œ" + distText +
                     "ã€‚åœ¨çŸ­æœŸå†…ï¼Œå®ƒæ›´å¤šåæ˜ è¿™ä¸€ä»·ä½é™„è¿‘çš„å¯¹å†²å‹åŠ›åˆ†å¸ƒï¼Œ" + sideHint + "ã€‚";
            }
            if (isShort && d > 3 && d < 12) {
              return "è¿™æ˜¯ä¸€å µè¿‘æœˆã€ç•¥é«˜äºæ ‡çš„ä»·çš„å¢™ï¼Œ" + distText +
                     "ã€‚" + sideHint + "ï¼Œå¯è§†ä¸ºä¸Šæ–¹åŒºåŸŸçš„ä¸€å¤„é‡è¦æŒä»“ç»“æ„ä½ç½®ã€‚";
            }
            if (isShort && d < -3 && d > -12) {
              return "è¿™æ˜¯ä¸€å µè¿‘æœˆã€ç•¥ä½äºæ ‡çš„ä»·çš„å¢™ï¼Œ" + distText +
                     "ã€‚" + sideHint + "ï¼Œæ›´å¤šä½“ç°ä¸‹æ–¹ä¿æŠ¤ / å¯¹å†²ä»“çš„é›†ä¸­åŒºåŸŸã€‚";
            }
            if (!isShort || Math.abs(d) >= 15) {
              return "è¿™æ˜¯ä¸€å µä»·æ ¼ç›¸å¯¹æ ‡çš„è¾ƒè¿œã€ä¸”åˆ°æœŸæ—¥åé•¿æˆ–è¾ƒè¿œçš„å¢™ï¼Œ" + distText +
                     "ã€‚è¿™ç±»å¢™é€šå¸¸æ›´å¤šåæ˜ é•¿æœŸèµ„äº§é…ç½®æˆ–ç»“æ„æ€§å¯¹å†²ï¼Œå¯¹è¿‘æœŸä»·æ ¼èŠ‚å¥çš„ç›´æ¥å½±å“æœ‰é™ã€‚";
            }
            return "é€‰ä¸­è¿™ä¸€è¡Œæƒä»·åï¼Œå¯ä»¥çœ‹åˆ°è¯¥ä»·ä½åœ¨å½“å‰ DTE æ¡¶ä¸­çš„æŒä»“ç»“æ„ï¼ˆ" +
                   sideHint + "ï¼‰ï¼Œä¸»è¦ç”¨äºç†è§£ä¸åŒä»·ä½é—´çš„å¯¹å†²å‹åŠ›åˆ†å¸ƒã€‚";
          }

          function makeHistoryInterpret(series) {
            if (!series || !series.length) return "";
            if (series.length < 3) {
              return "å†å²æ ·æœ¬è¾ƒå°‘ï¼ŒOI ä¸æˆäº¤é‡çš„å˜åŒ–èŠ‚å¥è¿˜ä¸å¤Ÿæ¸…æ™°ï¼Œæ›´é€‚åˆä½œä¸ºç»“æ„å‚è€ƒã€‚";
            }
            const first = Number(series[0].oi) || 0;
            const last = Number(series[series.length - 1].oi) || 0;
            const base = Math.max(Math.abs(first), 1e-6);
            const change = (last - first) / base;

            if (change > 0.5) {
              return "ä»å†å² OI è½¨è¿¹çœ‹ï¼Œè¿™å µå¢™ç›¸è¾ƒèµ·ç‚¹æœ‰æ˜æ˜¾æ”¾å¤§ï¼Œæ›´åƒæ˜¯æœ€è¿‘ä¸€æ®µæ—¶é—´è¢«æŒç»­â€œåŠ åšâ€çš„å¢™ã€‚";
            }
            if (change < -0.5) {
              return "å†å² OI è½¨è¿¹æ˜¾ç¤ºï¼Œè¿™å µå¢™ç›¸è¾ƒé«˜ä½å·²æœ‰æ˜æ˜¾å›è½ï¼Œå¯èƒ½æ˜¯åŸæœ‰ä»“ä½åœ¨é€æ­¥å‡ä»“æˆ–è¿ç§»ã€‚";
            }
            return "è¿™å µå¢™çš„ OI åœ¨è§‚å¯ŸæœŸå†…æ•´ä½“å˜åŒ–ç›¸å¯¹æ¸©å’Œï¼Œæ›´åƒæ˜¯ä¸€å µé•¿æœŸå­˜åœ¨çš„â€œè€å¢™â€ã€‚";
          }

          // æ ‡çš„é€‰æ‹©
          function initSymbolSelect() {
            symbolSelect.innerHTML = "";
            symbolKeys.forEach(k => {
              const opt = document.createElement("option");
              opt.value = k;
              const name = symbols[k].display_name || k;
              opt.textContent = k + " - " + name;
              if (k === currentSymbol) opt.selected = true;
              symbolSelect.appendChild(opt);
            });
            symbolSelect.addEventListener("change", () => {
              currentSymbol = symbolSelect.value;
              currentStrike = null;
              currentExpiration = null;
              currentSideForHistory = "C";
              mainInterpret.textContent = "";
              expiryInterpret.textContent = "";
              historyInterpret.textContent = "";
              renderMainChart();
              clearExpiryChart();
              clearHistoryChart();
              updateSideTabs();
            });
          }

          // DTE tabs
          function initDteTabs() {
            dteTabsContainer.innerHTML = "";
            Object.entries(dteBuckets).forEach(([key, bucket]) => {
              const btn = document.createElement("button");
              btn.type = "button";
              btn.className = "dte-tab" + (key === currentBucketKey ? " active" : "");
              btn.textContent = bucket.label;
              btn.dataset.key = key;
              btn.addEventListener("click", () => {
                currentBucketKey = key;
                currentStrike = null;
                currentExpiration = null;
                mainInterpret.textContent = "";
                expiryInterpret.textContent = "";
                historyInterpret.textContent = "";
                updateDteTabActive();
                renderMainChart();
                clearExpiryChart();
                clearHistoryChart();
              });
              dteTabsContainer.appendChild(btn);
            });
          }

          function updateDteTabActive() {
            const buttons = dteTabsContainer.querySelectorAll("button.dte-tab");
            buttons.forEach(btn => {
              if (btn.dataset.key === currentBucketKey) btn.classList.add("active");
              else btn.classList.remove("active");
            });
          }

          // ç¬¬äºŒå±‚ Call/Put åˆ‡æ¢æŒ‰é’®
          function initSideTabs() {
            const buttons = sideTabsContainer.querySelectorAll("button.side-tab");
            buttons.forEach(btn => {
              btn.addEventListener("click", () => {
                currentSideForHistory = normSide(btn.dataset.side);
                updateSideTabs();
                renderExpiryChart();
                clearHistoryChart();
              });
            });
            updateSideTabs();
          }

          function updateSideTabs() {
            const buttons = sideTabsContainer.querySelectorAll("button.side-tab");
            buttons.forEach(btn => {
              const side = normSide(btn.dataset.side);
              if (side === normSide(currentSideForHistory)) btn.classList.add("active");
              else btn.classList.remove("active");
            });
          }

          function clearExpiryChart() {
            expirySubtitle.textContent = "";
            expiryInterpret.textContent = "";
            const div = document.getElementById("expiry-chart");
            if (div) Plotly.purge(div);
          }

          function clearHistoryChart() {
            historySubtitle.textContent = "";
            historyInterpret.textContent = "";
            const div = document.getElementById("history-chart");
            if (div) Plotly.purge(div);
          }

          // ç¬¬ä¸€å±‚ï¼šDTE æ¨ªæˆªé¢ï¼ˆåªé€‰ä»·ä½ï¼‰
          function renderMainChart() {
            const div = document.getElementById("main-chart");
            if (!div || !currentSymbol) return;

            const recs = getRecordsForBucket(currentSymbol, currentBucketKey);
            const symObj = symbols[currentSymbol];
            const underlying = symObj && symObj.underlying;
            const bucket = dteBuckets[currentBucketKey];

            const stats = buildStrikeStats(recs, underlying, bucket);
            lastMainStats = stats;
            mainInterpret.textContent = "";

            if (!stats.length) {
              Plotly.newPlot(div, [], {
                title: "å½“å‰ DTE æ¡¶å†…æ²¡æœ‰æ˜¾è‘—çš„æœŸæƒå¢™ï¼ˆè¿‡æ»¤åï¼‰",
                paper_bgcolor: "#020617",
                plot_bgcolor: "#020617",
                font: { color: "#e5e7eb" }
              });
              mainSubtitle.textContent = "";
              return;
            }

            const strikes = stats.map(o => o.strike);
            const callVals = stats.map(o => (o.callDelta || 0) / 1e8);
            const putVals = stats.map(o => (o.putDelta || 0) / 1e8);

            const callTrace = {
              x: strikes,
              y: callVals,
              type: "bar",
              name: "Call Î”åä¹‰ï¼ˆäº¿ï¼‰",
              marker: { color: COLORS.call },
            };
            const putTrace = {
              x: strikes,
              y: putVals,
              type: "bar",
              name: "Put Î”åä¹‰ï¼ˆäº¿ï¼‰",
              marker: { color: COLORS.put },
            };

            const shapes = [];
            if (underlying) {
              shapes.push({
                type: "line",
                xref: "x",
                yref: "paper",
                x0: underlying,
                x1: underlying,
                y0: 0,
                y1: 1,
                line: {
                  color: "rgba(59,130,246,0.9)",
                  width: 1,
                  dash: "dot"
                }
              });
            }

            const layout = {
              barmode: "group",
              paper_bgcolor: "#020617",
              plot_bgcolor: "#020617",
              font: { color: "#e5e7eb" },
              margin: { l: 50, r: 10, t: 24, b: 40 },
              xaxis: { title: "è¡Œæƒä»·ï¼ˆè¿‡æ»¤åçš„ Top10 å¢™ï¼‰", showgrid: false },
              yaxis: { title: "Î”åä¹‰ï¼ˆäº¿ï¼‰", showgrid: true, gridcolor: "#111827" },
              showlegend: true,
              shapes: shapes
            };

            Plotly.newPlot(div, [callTrace, putTrace], layout);

            const bucketLabel = bucket ? bucket.label : "";
            let subtitle = currentSymbol + " Â· " + (symObj.display_name || "") + " Â· " + bucketLabel;
            if (underlying) {
              subtitle += " Â· æ ‡çš„ä»· â‰ˆ " + underlying.toFixed(2);
            }
            mainSubtitle.textContent = subtitle;

            // ä¸»å›¾ç‚¹å‡»ï¼šåªé€‰ strikeï¼Œä¸æ”¹ side
            div.on("plotly_click", function(ev) {
              if (!ev || !ev.points || !ev.points.length) return;
              const pt = ev.points[0];
              currentStrike = pt.x;
              currentExpiration = null;

              if (lastMainStats && underlying) {
                const match = lastMainStats.find(o => Math.abs(Number(o.strike) - Number(currentStrike)) < 1e-6);
                if (match) {
                  mainInterpret.textContent = makeMainInterpret(currentStrike, match, underlying, bucket);
                } else {
                  mainInterpret.textContent = "";
                }
              } else {
                mainInterpret.textContent = "";
              }

              renderExpiryChart();
              clearHistoryChart();
            });
          }

          // ç¬¬äºŒå±‚ï¼šåˆ°æœŸæ—¥åˆ†å¸ƒï¼ˆä»·ä½ + ä¾§åˆ«ï¼‰
          function renderExpiryChart() {
            const div = document.getElementById("expiry-chart");
            if (!div || currentStrike == null || !currentSymbol) return;

            const recs = getRecordsForBucket(currentSymbol, currentBucketKey);
            const side = normSide(currentSideForHistory);
            const agg = aggregateByExpiration(recs, currentStrike, side);
            expiryInterpret.textContent = "";

            if (!agg.length) {
              Plotly.newPlot(div, [], {
                title: "è¯¥è¡Œæƒä»·åœ¨å½“å‰ DTE æ¡¶å†…æ²¡æœ‰æ˜¾è‘—æŒä»“ï¼ˆå½“å‰ä¾§åˆ«ï¼š" + (side === "C" ? "Call" : "Put") + "ï¼‰",
                paper_bgcolor: "#020617",
                plot_bgcolor: "#020617",
                font: { color: "#e5e7eb" }
              });
              expirySubtitle.textContent = "";
              return;
            }

            const expirations = [...new Set(agg.map(r => r.expiration))].sort();
            const yVals = expirations.map(exp => {
              const rows = agg.filter(r => r.expiration === exp);
              return rows.reduce((s, r) => s + (r.delta || 0), 0) / 1e8;
            });

            const trace = {
              x: expirations,
              y: yVals,
              type: "bar",
              name: side === "C" ? "Call Î”åä¹‰ï¼ˆäº¿ï¼‰" : "Put Î”åä¹‰ï¼ˆäº¿ï¼‰",
              marker: { color: side === "C" ? COLORS.call : COLORS.put }
            };

            const layout = {
              barmode: "group",
              paper_bgcolor: "#020617",
              plot_bgcolor: "#020617",
              font: { color: "#e5e7eb" },
              margin: { l: 50, r: 10, t: 24, b: 60 },
              xaxis: { title: "åˆ°æœŸæ—¥", tickangle: -45, showgrid: false },
              yaxis: { title: "Î”åä¹‰ï¼ˆäº¿ï¼‰", showgrid: true, gridcolor: "#111827" },
              showlegend: true
            };

            Plotly.newPlot(div, [trace], layout);

            expirySubtitle.textContent =
              currentSymbol + " " + (side === "C" ? "Call" : "Put") +
              " @ è¡Œæƒä»· " + currentStrike + " Â· å„åˆ°æœŸæ—¥ Î”åä¹‰åˆ†å¸ƒ";

            // ç‚¹å‡»åˆ°æœŸæ—¥ -> ç¬¬ä¸‰å±‚
            div.on("plotly_click", function(ev) {
              if (!ev || !ev.points || !ev.points.length) return;
              const pt = ev.points[0];
              currentExpiration = pt.x;

              const totalDelta = yVals.reduce((sum, v) => sum + Math.abs(v || 0), 0);
              const idx = expirations.indexOf(currentExpiration);
              if (totalDelta > 0 && idx >= 0) {
                const sel = Math.abs(yVals[idx] || 0);
                const share = sel / totalDelta;
                if (share > 0.5) {
                  expiryInterpret.textContent =
                    "åœ¨å½“å‰è¡Œæƒä»·é™„è¿‘ï¼Œè¿™ä¸€åˆ°æœŸæ—¥åœ¨è¯¥ä¾§æŒä»“ä¸­å æ¯”è¾ƒé«˜ï¼Œè¯´æ˜è¿™ä¸€æ—¶é—´çª—å£çš„å¯¹å†²ä¸ä»“ä½è°ƒæ•´å¯èƒ½æ›´ä¸ºæ´»è·ƒã€‚";
                } else if (share > 0.25) {
                  expiryInterpret.textContent =
                    "è¿™ä¸€åˆ°æœŸæ—¥åœ¨è¯¥ä¾§æŒä»“ä¸­æœ‰ä¸€å®šæƒé‡ï¼Œä½†å¹¶éå”¯ä¸€ä¸»å¯¼ï¼Œæ•´ä½“ç»“æ„ç›¸å¯¹åˆ†æ•£ã€‚";
                } else {
                  expiryInterpret.textContent =
                    "è¿™ä¸€åˆ°æœŸæ—¥åœ¨è¯¥ä¾§æŒä»“ä¸­å æ¯”è¾ƒå°ï¼Œæ›´é€‚åˆä½œä¸ºç»“æ„èƒŒæ™¯å‚è€ƒã€‚";
                }
              } else {
                expiryInterpret.textContent = "";
              }

              renderHistoryChart();
            });
          }

          // ç¬¬ä¸‰å±‚ï¼šå†å² OI / Volume
          function renderHistoryChart() {
            const div = document.getElementById("history-chart");
            if (!div || currentStrike == null || !currentSymbol || !currentExpiration || !currentSideForHistory) return;

            const side = normSide(currentSideForHistory);
            const series = getHistorySeries(currentSymbol, currentStrike, currentExpiration, side);
            if (!series.length) {
              Plotly.newPlot(div, [], {
                title: "å†å²æ•°æ®ä¸è¶³ï¼Œæ— æ³•ç»˜åˆ¶ OI / æˆäº¤é‡è½¨è¿¹ï¼ˆå½“å‰ä¾§åˆ«ï¼š" + (side === "C" ? "Call" : "Put") + "ï¼‰",
                paper_bgcolor: "#020617",
                plot_bgcolor: "#020617",
                font: { color: "#e5e7eb" }
              });
              historySubtitle.textContent = "";
              historyInterpret.textContent = "";
              return;
            }

            const x = series.map(r => r.trade_date);
            const oiVals = series.map(r => Number(r.oi) || 0);
            const volVals = series.map(r => Number(r.volume) || 0);

            const isCall = side === "C";
            const oiColor = isCall ? COLORS.call : COLORS.put;
            const volColor = isCall ? COLORS.callLight : COLORS.putLight;

            const oiTrace = {
              x: x,
              y: oiVals,
              type: "bar",
              name: "æœªå¹³ä»“é‡ OI",
              marker: { color: oiColor }
            };
            const volTrace = {
              x: x,
              y: volVals,
              type: "bar",
              name: "æˆäº¤é‡ Volume",
              marker: { color: volColor }
            };

            const layout = {
              barmode: "group",
              paper_bgcolor: "#020617",
              plot_bgcolor: "#020617",
              font: { color: "#e5e7eb" },
              margin: { l: 50, r: 10, t: 24, b: 40 },
              xaxis: { title: "äº¤æ˜“æ—¥", showgrid: false },
              yaxis: { title: "åˆçº¦æ•°é‡", showgrid: true, gridcolor: "#111827" },
              showlegend: true
            };

            Plotly.newPlot(div, [oiTrace, volTrace], layout);

            const sideLabel = side === "C" ? "Call" : "Put";
            historySubtitle.textContent =
              currentSymbol + " " + sideLabel + " @ " + currentStrike +
              " Â· åˆ°æœŸæ—¥ " + currentExpiration + " Â· OI / æˆäº¤é‡å†å²è½¨è¿¹";

            historyInterpret.textContent = makeHistoryInterpret(series);
          }

          function init() {
            if (!currentSymbol) return;
            initSymbolSelect();
            initDteTabs();
            initSideTabs();
            renderMainChart();
          }

          init();
        } catch (e) {
          console.error("WALL V2 åŠ è½½å¤±è´¥ï¼š", e);
          const errBox = document.createElement("pre");
          errBox.style.whiteSpace = "pre-wrap";
          errBox.style.fontSize = "12px";
          errBox.style.background = "#fee";
          errBox.style.border = "1px solid #f00";
          errBox.style.padding = "8px";
          errBox.textContent = "WALL V2 åŠ è½½å¤±è´¥ï¼š" + e.message +
            "ã€‚å¦‚æœæ˜¯æœ¬åœ° file:// æ‰“å¼€ï¼Œè¯·æ”¹ç”¨ http æ–¹å¼ï¼ˆä¾‹å¦‚ python3 -m http.serverï¼‰ã€‚";
          document.body.prepend(errBox);
        }
      }

      document.addEventListener("DOMContentLoaded", initAll);
    })();
  </script>

  
</body>
</html>